## 레디스의 자료 구조

### String

- 데이터를 저장하는 가장 간단한 자료 구조
- 최대 512MB 저장
- 이진 데이터를 포함하는 모든 종류의 문자열이 binary-safe 처리됨 `->` JPEG 이미지, HTTP 응답값 등 다양한 바이너리 데이터 저장 가능
- `키-실제 데이터`가 일대일로 연결되는 유일한 자료 구조 (다른 자료구조는 `하나의 키에 여러 개의 아이템` 저장)

### list

- 순서를 가지는 문자열의 목록
- 추가, 삭제는 list의 양 끝에서만 수행할 수 있음
- 하나의 list에는 최대 42억여 개의 아이템을 저장
- 인덱스를 이용해 데이터에 직접 접근할 수 있음
- 일반적으로 list는 서비스에서 스택과 큐로서 사용
- LPUSH 커맨드는 list의 왼쪽(head)에 데이터를 추가하며, RPUSH 커맨드는 list의 오른 쪽(tail)에 데이터를 추가
- LRANGE 커맨드를 이용하면 list에 들어 있는 데이터를 조회할 수 있음

### hash

- 필드-값 쌍을 가진 아이템의 집합
- 하나의 hash 자료 구조 내에서 아이템은 `필드-값` 쌍으로 저장
- 필드는 하나의 hash 내에서 유일하며, 필드와 값 모두 문자열 데이터로 저장
- hash에서는 각 아이템마다 다른 필드를 가질 수 있으며, 동적으로 다양 한 필드를 추가할 수 있음. hash에는 새로운 필드에 데이터를 저장할 수 있기 때문에 조금 더 유연한 개발이 가능
- hash는 객체를 표현하기 적절한 자료 구조이기 때문에 관계형 데이터베이스의 테이블 데이터로 변환하는 것도 간편

### Set

- 레디스에서 set은 정렬되지 않은 문자열의 모음
- 하나의 set 자료 구조 내에서 아이템은 중복해서 저장되지 않으며 교집합, 합집합, 차집합 등의 집합 연산과 관련한 커맨드를 제공하기 때문에 객체 간의 관계를 계산하거나 유일한 원소를 구해야 할 경우에 사용될 수 있음
- SADD 커맨드를 사용하면 set에 아이템을 저장할 수 있음

### Sorted Set

!https://velog.velcdn.com/images/claraqn/post/e2f0d8c3-4f92-438e-a8ac-cb908fc548fd/image.png

- Set 이란 스코어(score) 값에 따라 정렬되는 고유한 문자열의 집합
- 모든 아이템은 `스코어-값` 쌍을 가짐
- 저장될 때부터 스코어 값으로 정렬돼 저장. 같은 스코어를 가진 아이템은 데이터의 사전 순으로 정렬돼 저장
- 데이터는 중복되지 않고 유일하기 때문에 set과 비슷하며, 각 아이템은 스코어라는 데이터에 연결된다는 점에서는 hash와 비슷하다고 생각할 수 있음
- 모든 아이템은 스코어 순으로 정렬되기 때문에 list에서와 같이 인덱스를 이용해 각 아이템에 접근할 수 있음

### Bitmap

- 독자적인 자료 구조는 아니며, string 자료 구조에 bit 연산을 수행할 수 있도록 확장한 것
- string 자료 구조가 binary safe(`데이터 손실없이 null 바이트를 포함한 모든 바이트 시퀀스를 저장, 처리, 조작할 수 있는 문자열 처리 방식` )하고 최대 512MB의 값을 저장할 수 있는 구조이기 때문에, 2^32의 비트를 가지고 있는 비트맵 형태라고 볼 수 있는 것
- 저장 공간을 획기적으로 줄일 수 있음
- 각각의 유저가 정수 형태의 ID로 구분되고, 전체 유저가 40억이 넘는다고 해도 각 유저에 대한 y/n 데이터는 512MB 안에 충분히 저장

### Hyperloglog

- 집합의 원소 개수인 카디널리티를 추정할 수 있는 자료 구조
- 대량 데이터에서 중복되지 않는 고유한 값을 집계할 때 유용하게 사용할 수 있음
- (비교) set과 같은 데이터 구조는 중복을 피하기 위해 저장된 데이터를 모두 기억하고 있기 때문에, 저장되는 데이터가 많아질수록 그만큼 많은 메모리를 사용 ↔️ hyperLoglog는 입력되는 데이터 그 자체를 저장하지 않고 자체적인 방법으로 데이터를 변경해 처리하기 때문에 저장되는 데이터 개수에 구애받지 않고 계속 일정한 메모리를 유지할 수 있음
- hyperloglog 자료 구조는 최대 12KB의 크기이며, 레디스에서 카디널리티 추정의 오차는 0.81%로, 비교적 정확하게 데이터를 추정 가능
- 하나의 hyperloglog에는 최대 18,446,744,073,709,551,616(264)개의 아이템을 저장

### Geospatial

!https://velog.velcdn.com/images/claraqn/post/b2a07d1b-4d67-46a9-ae22-48f66da92ef4/image.png

- 경도, 위도 데이터 쌍의 집합으로 간편하게 지리데이터를 저장할 수 있는 방법
- 내부적으로 데이터는 sorted set으로 저장되며, 하나의 자료구조 안에 키중복은 없음
- sorted set과 마찬가지로 XX 옵션을 사용하면 이미 아이템이 있는 경우에만, NX 옵션을 사용하면 아이템이 없는 경우에만 데이터를 저장

### stream

- 레디스를 메시지 브로커로서 사용할 수 있게 하는 자료 구조
- 카프카에서처럼 소비자 그룹 개념을 도입해 데이터를 분산 처리할 수 있는 시스템
- 데이터는 계속해서 추가되는 방식(append-only) -> 실시간 이벤트 혹은 로그성 데이터를 큐잉하기 위해 사용 가능

### 키의 자동생성과 삭제

- 하나의 키가 여러개의 아이템을 가지고 있는 자료구조(`stream, set, sorted set, hash`)에서는 명시적으로 키를 생성하거나 삭제하지 않아도 키는 알아서 생성되고 삭제

### 키와 관련된 커맨드

- 자료 구조에 상관없이 모든 키에 공통적으로 사용할 수 있는 커맨드

EXISTS

- 키가 존재하는지 확인하는 커맨드
- 키가 존재하면 1을, 존재하지 않으면 0

KEYS

- 레디스에 저장된 모든 키를 조회하는 커맨드
- 매칭되는 패턴( 글롭 패턴 )에 해당하는 모든 키의 list를 반환

COPY

- Source에 지정된 키를 destination 키에 복사
- destination에 지정한 키가 이미 있는 경우 에러가 반환

FLUSHALL

- 레디스에 저장된 모든 키를 삭제
- 기본적으로 FLUSHALL 커맨드는 SYNC한 방식으 로 동작해 모든 데이터가 삭제된 경우에만 OK를 반환해서 커맨드가 실행되는 도중에 는 다른 응답을 처리할 수 없음
- ASYNC 옵션을 사용하면 flush는 백그라운드로 실행 되며 커맨드가 수행됐을 때 존재했던 키만 삭제하며, flush되는 중 새로 생성된 키는 삭제되지 않음

DEL

- 키와 키에 저장된 모든 아이템을 삭제하는 커맨드
- 기본적으로 동기적으로 작동

UNLINK

- 키와 키에 저장된 모든 아이템을 삭제하는 커맨드
- 백그라운드에서 다른 스레드에 의해 처리되며, 우선 키와 연결된 데이터의 연결을 끊음

TTL

- 키가 몇 초 뒤에 만료되는지 반환
- 키가 존재하지만 만료시간이 설정돼 있지 않은 경우에는 -1을, 키가 없을 때 에는 -2를 반환한다.

EXPIRE

- 키가 만료될 시간을 초 단위로 정의 가능
- 해당 옵션 사용 가능

EXPIREAT

- 키가 특정 unix timestamp에 만료될 수 있도록 키의 만료 시간을 직접 지정
- 해당 옵션 사용 가능

EXPIRETIME

- 키가 삭제되는 unix timestamp를 초 단위로 반환
- 키가 존재하지만 만료시간이 설정돼 있지 않은 경우에는 -1을, 키가 없을 때에는 -2를 반환