### **레디스 복제를 하는 이유 세 가지**

1. 마스터 데이터베이스가 다운됐을 때 대신 사용할 여분의 복제본이 필요함.
2. 부하 분산을 통해 마스터 노드로의 트래픽을 줄일 수 있음.
3. 백업을 복제본에서 수행하면 백업이 서비스에 미치는 영향도를 최소화 할 수 있음

**레디스 2.6부터는 복제본 노드는 읽기 전용으로만 동작하며 마스터에서 변경된 데이터를 그대로 받아온다.**

---

### **복제 구조 구성**

```java
REPLICAOF <master-ip> <master-port>
```

- 복제본이 될 노드에서 커맨드를 입력해 마스터 노드의 정보를 입력하면 복제 연결이 시작됨
- 마스터 노드가 예기치 못한 장애로 인해 사용하지 못하게 됐을 때에는 애플리케이션의 연결 설정을 B로 변경하면 서비스를 계속할 수 있다.
- 마스터 노드 1 : N 복제 노드 구조로 복제의 복제도 가능하나 하나의 노드의 마스터는 무조건 1
- requirepass 옵션이 설정되어 있으면 복제할때 masterpass 옵션으로 패스워드 입력해야함

---

### **복제 ID**

- 모든 레디스 인스턴스는 복제 ID(replication ID)를 가지고 있다.

INFO REPLICATION 커맨드로 복제 연결 상태를 확인 가능함.

- 복제 연결을 시작하면 복제본의 replication id는 마스터의 replication id로 변경됨
- 오프셋은 복제본에서 마지막으로 수행된 마스터의 오프셋을 의미

---

### **부분 재동기화**

- 복제 연결이 끊길 때마다 마스터에서 RDB 파일을 새로 내려 복제본에 전달하는 과정을 계속 거치면 성능이 나빠질 것이다.
- 재연결된 복제본은 psync 커맨드를 호출해 자신의 replication id 와 오프셋을 마스터에 전달한다.
    - 마스터는 백로그 버퍼라는 메모리 공간에 복제본에 전달한 커맨드 데이터들을 저장해둠
    - 오프셋이 900이고 마스터의 오프셋이 915라면 901~915의 내용이 마스터에 백로그에서 복제본에 전달함으로써 부분 재동기화를 진행할 수 있다.

하지만, 버퍼에 원하는 데이터가 없다면 전체 재동기화를 시도한다.

---

### **레디스가 2개의 복제 ID를 갖는 이유**

1. 마스터 노드에 장애가 일어남
2. 마스터에 연결되어있던 B 와 C중 B가 마스터로 승격됨
3. 기존의 복제 ID는 마스터 노드의 ID를 갖고 있기 때문에 그대로 사용해선 안됨
    1. 장애가 복구됐을때 동일한 오프셋이 동일한 데이터셋을 갖는다는 사실을 위반할 수 있기 때문
4. B가 마스터로 승격되며 새로운 복제 ID를 갖게됨, 기존 복제 ID는 mster_replid2에 저장됨
5. B가 갖고있는 ID를 C의 복제 ID로 갖게됨, 기존 복제 ID는 mster_replid2에 저장됨

---

### 백업을 사용하지 않는 경우에서의 데이터 복제

- 레디스에서 복제를 사용하는 경우 마스터와 복제본에서 백업 기능을 사용하는 것이 좋다.
- 백업을 사용하지 않으려면 재부팅 후 레디스가 자동으로 재시작되지 않도록 설정할 것을 권장함.

**백업 안쓸거면 레디스 자동 재시작 안하길 권장하는 이유**

1. 마스터 죽음
2. 마스터 재부팅(백업안하면 초기화)
3. 마스터의 초기화된 데이터를 복제로 전달
4. 복제도 초기화됨

- 백업을 사용 안할 것이라면 마스터가 죽었다 다시 연결될때 마스터를 복제로 만들어 버리면 됨
