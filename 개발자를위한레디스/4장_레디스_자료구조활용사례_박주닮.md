# 소개

---

레디스 자료 구조에 내장된 함수를 이용해 원하는 기능을 사용하면 데이터를 애플리케이션의 메모리 영역으로 가져간 뒤 가공하는 데에 걸리는 시간을 줄일 수 있기 때문에 레디스가 제공하는 다양한 자료 구조를 적절히 활용한다면 애플리케이션에서는 매우 짧은 대기 시간으로 엄청난 양의 작업을 처리할 수 있다.

### 리더보드란?

- 사용자의 스코어를 기반으로 데이터를 정렬하는 서비스이기 때문에 사용자의 증가에 따라 가공해야 할 데이터가 몇 배로 증가합니다.
- 실시간으로 반영돼야 하는 데이터입니다.
    - 스코어가 100에서 110으로 변경되면 순위 상승 등

### 레디스 sorted set을 활용

유저의 스코어를 sorted set의 가중치로 설정하면 스코어 순으로 유저가 정렬되는 것을 활용합니다.

### sorted set에 데이터 저장

![image](https://github.com/user-attachments/assets/75be1335-ed5c-4010-b443-2f83782ea58f)

### 오름차순 출력

![image (1)](https://github.com/user-attachments/assets/f7703d24-e9a7-432e-b241-790f350640ae)

- withscores를 붙이면 값과 score가 순차적으로 같이 출력됩니다.

### 내림차순 출력

![image (2)](https://github.com/user-attachments/assets/f87f56c9-47f9-436a-bd29-8c7c7584d615)

- 0 2 란 0번 인덱스부터 2번 인덱스까지 즉 [0 1 2] 3개만 출력하라는 뜻입니다.

### 데이터 업데이트

player:1이 이겨서 점수가 올랐다고 가정해 보면

![image (3)](https://github.com/user-attachments/assets/db117c5c-670c-4bc5-96a5-b143257c7f7b)

위와같이 특정 날짜의 상위 N명의 유저만 출력하고 싶은 실시간 리더보드를 간단하게 구현할 수 있습니다.

### 관계형 데이터베이스로도 할 수 있는 것 아닌가요?

관계형 데이터베이스만 이용해 실시간 차트 서비스를 구현하는 것은 모든 유저의 변경 데이터를 실시간으로 업데이트 하는작업 + 점수별로 sorting 하는 작업 자체가 상당한 부하기 때문에 유저가 굉장히 많다고 생각하면 처리 시간이 굉장히 길어집니다.

⇒ 너무 비효율적

### 랭킹 합산

![image (4)](https://github.com/user-attachments/assets/7f5866ee-fbbd-40df-8064-e2f4662f6269)

```java
$ zunionstore weekly-score:2208-3 3 daily-score:220815 daily-score:220816 daily-score:220817
```

<weekly-score:2208-3 생성할 키> <3 합산할 키 개수> <합산할 키 1 2…>

### 합산한 키 조회

![image (5)](https://github.com/user-attachments/assets/4dd7cf58-edda-481a-9113-1c09a3e71791)

참고로 스코어가 같을 때에는 사전 순으로 정렬됩니다.

### 합산시 가중치

![image (6)](https://github.com/user-attachments/assets/04bae094-a542-449e-b48c-2ea8e1e821cb)

```java
$ zunionstore weekly-score:2208-3 3 
daily-score:220815 daily-score:220816 daily-score:220817
weights 1 2 1
```

합산 시 weights 1 2 1 만 추가해주면 되는데 이 의미는 키의 위치마다 1 2 1을 곱한값을 지정해준다는 뜻입니다.

이를 활용해 특정 날에 이벤트를 열어 점수 2배 등의 구현을 간단하게 할 수 있습니다.

### 유저별 최근 검색 기록 요구사항

1. 유저별로 다른 키워드 노출
2. 검색 내역은 중복 제거
3. 가장 최근 검색한 5개의 키워드만 사용자에게 노출

이러한 요구사항도 위의 리더보드의 스코어를 날짜로만 바꿔준다면 아주 간단하게 구현 가능 합니다.

리더보드와 조금 다른 점은 가장 최근 검색한 5개의 키워드를 관리하는 방법인데 이건 음수 인덱스를 활용해서 구현합니다.

음수 인덱스란 가장 마지막에 저장된 인덱스가 -1이고 순차적으로 -2 -3 … -6 즉 역순으로 증가하는 값이므로 최신 인덱스가 추가될때마다 ⇒ -6 인덱스는 delete 해버리면 리소스 소모 없이 간단하게 구현 가능합니다.

```java
$ ZREMRANGEBYRANK search-keyword -6 -6
```

- ZREMRANGEBYRANK 명령어
- **key**: 대상 Sorted Set의 키 이름.
- **start**: 삭제를 시작할 순위(0부터 시작).
- **stop**: 삭제를 끝낼 순위.

위의 명령어는 -6부터 -6까지 즉 -6만 지우겠다 라는 뜻입니다.

### 교집합

![image (7)](https://github.com/user-attachments/assets/fcd3d753-315b-4c47-8884-4125855481fa)

### 좋아요 처리하기

특정 댓글 등에 좋아요를 구현하려면 하나의 유저는 같은 댓글에 한 번씩만 좋아요를 누를 수 있어야 하기 때문에 단순히 개수만을 파악하는 것이 아닌 어떤 유저가 어떤 댓글에 눌렀는지를 관리해야합니다.

뉴스 댓글 같은 경우에는 1초에 몇만 개 이상 트래픽이 발생할 수 있습니다.

이러한 상황은 Redis의 set을 댓글 id를 key로 유저의 id를 값으로 생성한다면 중복 없이 특정 댓글에 좋아요를 누른 유저를 나타낼 수 있습니다.

### Hash 구조로 관리

```java
$ HINCRBY user:234 channel:4234 1
(integer) 1
```

- 필드의 기존 값이 없으면 기본값 **0**에서 시작합니다.
- 음수를 사용하면 값을 감소시킬 수 있습니다.

### 레디스의 비트맵

```bash
$ SETBIT key offset value
```

- **`key`**: 비트를 저장할 Redis 키.
- **`offset`**: 설정할 비트의 위치(0부터 시작하는 인덱스).
- **`value`**: 설정할 값 (`0` 또는 `1`).

```java
$ BITCOUNT key
```

- **결과**: 설정된 비트(즉, 방문한 사용자 수) 총합을 조회할 수 있습니다.
- 주로 하루 동안 서비스에 방문한 사용자 수를 수집하는데 사용되며 1천망 명이 넘는 서비스에서도 1천만 개의 비트는 1.2MB 이므로 레디스 string 최대 길이는 512MB이기 때문에 하나의 키로 1천만 명의 사용자를 문제없이 카운팅 가능합니다.
- BITOP 커맨드로 AND 연산 등을 제공하기 때문에 연속 출석 유저 등을 손쉽게 구할 수 있다.

### 그 외

- hyperloglog(수십억 건의 중복을 제거하여 고유 항목의 개수 추정 약간의 오차(1%미만))
- geo set(공간 관리에 특화된 데이터 구조)
    - 지정 좌표 1km 내의 식당을 모두 찾는 등 구현 가능
