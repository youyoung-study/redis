## 1. 확장성 (Scalability): 스케일 업 vs 스케일 아웃
Redis의 확장성은 **스케일 업(Scale-Up)**과 **스케일 아웃(Scale-Out)**이라는 두 가지 방식으로 구분됩니다.

### 1.1 스케일 업 (Scale-Up)
- 기존 서버의 하드웨어 성능(CPU, RAM, 디스크)을 업그레이드하여 처리 용량을 늘리는 방식.
- 장점:
  - 간단한 방식으로 기존 시스템에 큰 수정 없이 성능을 개선 가능.
- 단점:
  - 하드웨어의 물리적 한계(CPU 코어 수, 메모리 크기 등)로 인해 더 이상 확장이 불가능.
  - 특정 순간 이후 성능 향상 비용 대비 효율이 낮아짐.
- 특징:
  - **수직 확장(Vertical Scaling)**으로 불림.
### 1.2 스케일 아웃 (Scale-Out)
- 여러 대의 서버를 연결하여 분산 처리 및 성능을 향상시키는 방식.
- 장점:
  - 무제한에 가까운 확장이 가능하며, 트래픽이나 데이터가 증가해도 대응 가능.
- 단점:
  - 데이터 분산 처리 로직(샤딩)과 관리 복잡성이 증가.
  - 네트워크 연결에 따른 추가적인 비용 발생.
- 특징:
  - **수평 확장(Horizontal Scaling)**으로 불림.
 
## 2. Redis의 확장성
Redis에서의 확장은 스케일 업보다는 스케일 아웃을 중심으로 설계되어 있으며, 이를 위해 클러스터 및 샤딩 기술을 제공합니다.

## 2.1 스케일 업
- 메모리 용량 제한을 늘리기 위해 maxmemory 설정을 조정.
- 단, CPU 자원의 한계로 인해 처리 성능은 특정 수준을 넘기 어렵다.
- 활용 사례:
  - 단일 노드에서 데이터를 캐싱하거나 메모리 성능 최적화.
## 2.2 스케일 아웃
- 샤딩(Sharding):
  - 데이터를 여러 서버에 나누어 분산 저장 및 처리.
  - Redis 클러스터를 사용해 자동화 가능.
- 병렬 처리:
  - 여러 서버에 작업을 분산하여 병렬로 요청을 처리, 처리량과 응답 속도 개선.
 
## 3. Redis 클러스터와 주요 기능
### 3.1 클러스터의 기본 동작
- 클러스터는 데이터를 **16,384개의 해시 슬롯(Hash Slot)**으로 나누어 저장.
- 각 노드는 특정 범위의 해시 슬롯을 담당하며, 데이터는 CRC16 해시 함수로 계산되어 적절한 슬롯에 매핑.
- 클러스터는 데이터를 분산 저장하며 노드 간 데이터 이동과 복제를 통해 고가용성을 보장.
### 3.2 데이터 샤딩
- 데이터를 여러 서버에 분산 저장하여 처리량을 향상.
- 노드 추가/삭제 시 자동으로 데이터 재배치 수행.
- 장점:
  - 데이터를 병렬로 처리하여 처리 속도와 성능 최적화.
### 3.3 고가용성(HA, High Availability)
- Redis는 마스터-슬레이브 구조를 통해 장애 복구와 고가용성을 지원.
- 장애 발생 시 슬레이브 노드를 승격시켜 시스템 중단을 방지.
- 복제본 개수를 통해 복구 신뢰도를 높임.

## 4. 데이터 처리 방식
### 4.1 해시 슬롯(Hash Slot)
- Redis 클러스터는 키를 해시슬롯에 매핑하여 데이터를 분산 저장.
- 총 16,384개의 슬롯으로 구성, 각 노드가 슬롯의 일부를 관리.
- 예:
  - 슬롯 0~5,455: 노드 1
  - 슬롯 5,456~10,922: 노드 2
  - 슬롯 10,923~16,383: 노드 3
### 4.2 키 분배 방식
- 데이터는 키에 대해 CRC16 계산을 수행하여 슬롯 번호를 결정.
- 해당 슬롯을 담당하는 노드로 요청을 전달.
### 4.3 해시태그(Hash Tag)
- 다중 키 명령(MGET, MSET 등)을 실행하려면 모든 키가 동일한 슬롯에 있어야 함.
- 해시태그를 사용하여 특정 키 그룹을 같은 슬롯에 배치.
- 예:
```text
user:{123}:name, user:{123}:profile → 같은 해시슬롯에 저장.
```

## 5. 자동 재구성(Auto-Reconfiguration)
- Redis 클러스터는 **고가용성(HA)**을 보장하기 위해 자동으로 노드를 재구성합니다.
- 장애가 발생한 마스터 노드는 다른 슬레이브 노드가 마스터로 승격되며, 클러스터가 재구성됩니다.
- 클러스터 내의 모든 노드는 서로 상태를 감시하며, 장애 발생 시 **자동 페일오버(Failover)**를 수행합니다.

### 5-1. 자동 페일오버(Failover)
- 마스터 노드가 장애로 인해 응답하지 않을 경우, 해당 마스터 노드에 연결된 슬레이브 중 하나가 투표 과정을 거쳐 마스터로 승격됩니다.
- 투표 메커니즘:
  - 클러스터 내 과반수 이상의 마스터 노드가 장애 상태를 확인하고 투표로 새 마스터를 결정.
 
### 5-2. 복제본 마이그레이션(Replica Migration)
- 특정 마스터에 복제본(slave)이 부족한 경우, 다른 마스터의 복제본을 재배치하여 균형을 맞춥니다.
- Redis 설정 옵션:
```
cluster-allow-replica-migration yes: 복제본 마이그레이션 허용.
cluster-migration-barrier N: 최소 N개의 복제본이 있어야 마이그레이션 진행.
```
### 5-3. 클러스터에서의 Redis-cli 사용

- redis-cli 명령어를 사용해 클러스터 모드에서 데이터 저장 시, 키의 해시 슬롯을 기반으로 적절한 노드로 리다이렉션.
- -c 옵션을 사용하면 리디렉션 과정을 자동 처리.
```
예시: set user:1 true 시, MOVED 메시지가 발생하며 해당 슬롯이 있는 노드로 데이터 이동.
```
### 5-4 Failover 테스트

- 수동으로 페일오버시키려면 페일오버시키고자 하는 마스터에 1개 이상의 복제본이 연결돼 있어야 한다.
- 수동 페일오버가 진행되는 동안 기존 마스터에 연결된 클라이언트는 잠시 블락된다.
- 페일오버가 완료되면 클러스터의 정보를 변경하고, 모든 작업이 완료되면 클라이언트는 새로운 마스터로 리디렉션된다.

자동 페일오버
- 클러스터 구조에서 복제본은 redis.conf에 지정한 cluster-node-timeout시간 동안 마스터에서 응답이 오지 않으면 마스터의 상태가 정상적이지 않다고 판단해 페일오버를 트리거 한다.

## 6. 레디스 클러스터 운영하기
### 6-1. 클러스터 리샤딩
- 리샤딩 정의 및 목적:

  - 리샤딩은 마스터 노드의 해시 슬롯 중 일부를 다른 마스터로 이동시키는 과정입니다.
  - 리샤딩은 노드 간의 데이터 분배를 재조정하여 성능과 균형을 유지합니다.

- 리샤딩 과정:

- Redis CLI 명령어 사용:
```
redis-cli --cluster reshard <IP>:<PORT>
```
- 이동할 슬롯 수와 데이터를 받을 노드 ID를 입력.
- all을 입력하면 소스 노드를 자동으로 선택하며, 특정 노드를 지정할 수도 있음.
- 확인 후 yes를 입력하면 리샤딩 작업이 진행됩니다.

### 6-2. 클러스터 리사이징 - 간단 버전
- redis-cli 명령어를 사용해 클러스터 내 슬롯을 자동으로 이동시킬 수 있음.
- --cluster-from, --cluster-to와 같은 옵션을 지정해 슬롯 이동 경로를 설정하며, --cluster-yes로 모든 프롬프트를 자동으로 진행 가능.
- 슬롯 이동 작업이 끝난 후 cluster nodes 명령어로 상태를 확인.

### 6-3 클러스터 확장 - 신규 노드 추가
- 신규 노드를 클러스터에 추가하려면 redis-cli --cluster add-node 명령어를 사용.
- 신규 마스터 또는 복제본 노드를 추가 가능.
- 새 노드를 추가할 경우 기존 노드의 상태를 확인하고 연결 설정을 검증해야 함.
- 복제본으로 추가하려면 --cluster-slave 옵션을 사용, 특정 마스터에 연결하려면 --cluster-master-id를 지정.

### 6-4. 노드 제거
- 노드를 클러스터에서 제거하려면 redis-cli --cluster del-node 명령어를 사용.
- 노드 제거 전 해당 노드의 데이터를 다른 노드로 리샤딩하거나 역할을 복제본으로 변경해야 함.

### 6-5. CLUSTER RESET
- SOFT와 HARD 두 가지 옵션 제공.
- SOFT: 데이터 삭제 없이 구성 초기화.
- HARD: 데이터와 구성 모두 삭제.
  
