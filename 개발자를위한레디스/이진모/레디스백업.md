AOF(append only file)
레디스 인스턴스가 처리한 모든 쓰기 작업을 차례대로 기록, 복원시에는 파일을 다시 읽어가며 데이터 세트 재구성
실수로 FlUSHALL 커맨드로 데이터를 모두 날려버렸다 해도 AOF 파일을 직접 열어 FLUSHALL 커맨드만 삭제한 뒤 레디스를 재시작 하면 커맨드를 실행하기 직전까지로 데이터 복구 가능
AOF 파일은 레디스 프로토콜 형태로 저장된다.
AOF 파일이 사용자가 실행한 커맨드를 그대로 저장되지는 않는다.
장점

RDB 파일보다 크기가 큼
원하는 시점으로 복구할 수 있음
단점

주기적으로 압축해 재작성해야함
설정파일에서 appendonly 옵션을 yes로 지정하면 AOF 파일에 주기적으로 데이터가 저장된다.

// AOF 파일에 주기적으로 데이터 저장 
appendonly yes 
//지정 경로
appendfilename "appendonly.aof"
//appendfilename 옵션에 설정한 이름
appenddirname "appendonlydir"


appendfilename 옵션을 이용해 AOF 파일명을 변경하지 않는다면 기본적으로 AOF 파일은 appendonly.aof 라는 이름으로 저장된다.

버전 7.0 이상부터는 AOF 파일은 여러 개로 저장되며, 이는 appenddirname 옵션에서 지정된 디렉터리 하위에 저장된다.

appenddirname 옵션에는 경로가 아닌 디렉터리 이름만 지정할 수 있으며, dir 옵션하위에 생성된다.



> SET key1 apple
OK

> SET key1 beer
OK

> DEL key1
(integer) 1

> DEL non_existing_key
(integer) 0
AOF 파일에는 메모리상의 데이터가 변경되는 커맨드만 기록되기 때문에 마지막의 DEL non)existing_key 작업은 기록되지 않는다.

메모리에 영향을 끼치는 위의 3개 작업만 기록됨

*3
$3
set
$4
key1
$5
apple
*3
$3
set
$4
key1
$4
beer
*2
$3
del
$4
key1
AOF 에서 모든 커맨드의 실행 내역은 위처럼 레디스 프로토콜 형식으로 저장된다.

* 배열의 시작을 나타낸다.
뒤에 오는 숫자는 배열의 요소 수를 나타낸다.
*3 -> 이 배열에는 3개의 요소가 있다는 의미. (set key1 apple)
$ : 문자열(String) 의 길이를 나타낸다.
뒤에 오는 숫자는 해당 문자열의 길이를 의미한다.
문자열 데이터: $ 뒤에 나오는 숫자만큼의 길이를 가진 실제 데이터이다.
예: $4 key1 -> 길이가 4인 문자열 key1
AOF 파일을 재구성 하는 방법
재구성은 기존 디스크에 저장됐던 AOF 파일을 사용하는 것이 아니라 레디스 메모리에 있는 데이터를 읽어와서 새로운 파일로 저장한다.



설정파일 옵션

aof-use-rdb-preamble yes : RDB 파일 형태로 저장한다.
aof-use-rdb-preamble no : 베이스 파일은 *.base.rdb 형태가 아닌 *.base.aof 로 저장되며 형태도 RESP 프로토콜 형태로 저장된다.
생성 파일

rdb 파일 : 바이너리 바이너리 형태의 파일
aof파일 : RESP(레디스 프로토콜) 형태로 저장되는 파일 
manifest 파일 : 현재 레디스가 바라보고 있는 파일
매니페스트 파일은 RDB와 AOF 파일이 어떤것인지 알려주는 역할을 한다. 세 파일은 모두 설정 파일에 지정한 appenddirname 이름의 폴더 내에 저장된다.



AOF 가 재구성될 때마다 AOF를 구성하고 있는 각 RDB와 AOF의 파일명의 번호 그리고 매니페스트 파일 내부의 seq 값도 1씩 증가한다.



동작순서

(버전 7 이후)

레디스 인스턴스는 fork를 이용해 자식 프로세스를 생성한다. 생성된 자식 프로세스는 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장한다.
백그라운드로 1의 과정이 진행되는 동안 레디스 메모리의 데이터가 변경된 내역은 신규 AOF 파일에 저장된다.
1의 AOF 재구성 과정이 끝나면 임시 매니페스트 파일을 덮어 씌운 뒤, 이전 버전의 AOF, RDB 파일들을 삭제한다.


자동 AOF  재구성
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

>INFO Persistence
# Persistence
...
aof_current_size:186830
aof_base_size:145802
...


auto-aof-rewurte-percentage 는 AOF 파일을 다시 쓰기 위한 시점을 정하기 위한 옵션이다.



현재의 aof_base_size 가 145802 일때 auto-aof-rewurte-percentage 가 100 이라면 aof_current_size 가 base_size의 100% 만큼 커진 291604 가 되면 자동으로 재구성을 시도한다.



데이터가 아무것도 없는 상태로 인스턴스가 처음 부팅됐을 떄의 aof_vase_size는 0이므로 이럴 떄에는 auto_aof_rewrite_min_size를 기준으로 데이터를 재구성한다.



수동 AOF 재구성
BGREWRITEAOF 커맨드를 이용하면 원하는 시점에 직접 AOF 파일을 재구성할 수 있다. 



AOF 타임스탬프
버전 7 이상부터는 AOF를 저장할 떄 타임스탬프를 남길 수있다.

aof-timestamp-enabled no
설정 파일에서 위 옵션을 활성화 시키면 AOF 데이터가 저장될 떄 타임스탬프도 함께 저장된다.



만약 사용자의 실수 로 FULSHALL 커맨드를 사용해 레디스의 모든 데이터를 삭제했다고 하여도 AOF 파일에 로그가 남기에

redis-check-aof 프로그램을 사용해 FLUSHALL 이 실행되기 전까지로 데이터를 복구할 수 있다.



AOF 파일 복원
레디스가 의도치 않은 장애로 중단됐을 떄 redis-check-aof 프로그램을 사용하면 AOF 파일의 상태가 정상적인지 확인할 수 있다.

만약 비정상적인 파일이 있을 경우 fix옵션을 사용하며 해결하라는 문구가 나온다. 

fix 옵션을 사용한 복구 또한 원본 파일을 변경하기 때문에 이전의 데이터를 보호하고 싶은 경우에는 원본 데이터를 다른 곳에 복사해두는 것이 안전하다.

RDB(Redis DataBase) 
특징

일정 시점에 메모리에 저장된 데이터 전체를 저장
RDB파일은 바이너리 형태로 저장돼 우리가 읽고 해석할 수 없는 형태이다.
장점

시점 단위로 여러 백업본을 저장할 수 있음
AOF 파일보다 복원이 빠름
단점

사용자가 지정한 단위로 파일이 저장되기 때문에 저장 시점부터 장애가 발생한 직전까지의 데이터는 손실될 수 있음
방법

설정 파일에서 특정 조건에 파일이 자동으로 저장되도록 지정
사용자가 원하는 시점에 커맨드를 이용해 수동으로 파일 생성
복제 기능을 사용하여 자동으로 RDB 파일 생성
자동으로 RDB 파일 생성
save <기간(초)> <기간 내 변경된 키의 개수>

ex) save 900 1 -> 900초 동안 1개 이상의 키가 변경된 경우 아래의 경로로 파일 생성

dbfilename <RDB 파일 이름>
dir <RDB 파일이 저장될 경로>


만약 RDB 파일을 저장하고 싶지 않다면 save "" 와 같이 빈 문자열로 설정 가능

인스턴스 실행중인 상태에서 RDB 저장을 비활성화 하고 싶다면 CONFIG SET 커맨드를 이용해 SAVE 파라미터를 ""로 초기화시키면 된다.

현재 적용된 save 옵션 확인
CONFIG GET save
"save"
"900 1 300 10 60 10000"

save 옵션 초기화
> CONFIG SET save ""
OK

현재 적용된 save 옵션 확인
> CONFIG GET save
"save"
""

redis.conf 파일 재작성
> CONFIG REWITE
ok


다만 레디스 인스턴스가 실행중인 상태에서 설정 파일을 변경하는 것은 실행중인 레디스 인스턴스에는 반영되지 않는다. 실행 중인 레디스 인스턴스에서 파라미터를 수정할 때에는 레디스 cli에서 직접 CONFIG SET커맨드로 설정을 변경한 뒤, CONFIG REWRITE 커맨드를 이용해 설정 파일을 재작성 해야한다. 



수동으로 RDB 파일 생성
SAVE, BGSAVE 커맨드를 이용하면 원하는 시점에 직접 RDB 파일을 생성할 수 있다. 

두 커맨드 모두 실행 시점의 메모리 스냅샷을 생성하는 커맨드이지만 동작방식에 차이가 있다.



SAVE

동기 방식으로 파일 저장
파일 생성이 완료될 때까지 다른 모든 클라이언트의 명령을 차단
파일 저장시까지 레디스 인스턴스에 연결된 다른 클라이언트는 아무 명령도 수행할 수 없기에 일반적인 운영환경에서는 SAVE 커맨드를 사용하지 않는 것을 추천
BGSAVE

fork를 호출해 자식 프로세스를 생성하며 자식 프로세스가 백그라운드에서 RDB 파일을 생성한 뒤 종료한다.
레디스를 이용하는 다른 클라이언트는 원래대로 부모 프로세스를 이용해서 처리되기 때문에 파일 저장에는 영향을 받지 않는다.
이미 백그라운드로 데이터가 저장되고 있을때 이커맨드를 수행하면 에러를 반환하다.
이런 상황에서는 BGSAVE 와 함께 SCHEDULE  옵션을 사용할 수 있는데 이미 파일이 백그라운드에서 저장 중일 때 이 커맨드를 입력받은 레디스는 일단 OK를 반환한 뒤, 기존에 진행 중이던 백업이 완료됐을 떄 다시 BGSAVE를 실행한다.
RDB 파일이 정상적으로 저장됐는지는 LASTSAVE 커맨드로 확인할 수 있으며, 마지막으로 RDB 파일이 저장된 시점을 유닉스 타임스탬프로 반환한다.

복원시기
레디스 서버는 재시작 될 떄 AOF 파일이나 RDB 파일이 존재하는지 확인한 뒤, 파일이 있을 때에는 파일을 로드한다. 레디스는 RDB 파일보다 AOF 파일이 더 내구성이 보장된다고 판단하기 때문에 2개의 파일이 모두 존재할 때에는 AOF의 데이터를 로드한다.

레디스에서 데이터를 복원할 수 있는 시점은 서버가 재시작될 때 뿐이며 레디스 인스턴스의 실행 도중에 데이터 파일을 읽어올 수 있는 방법은 없다.




