### 메시지 브로커의 필요성
- 최근의 서비스 아키텍처는 여러 모듈이 서로 느슨하게 연결된 구조이다.
- 이러한 구조는 모듈간 상호작용이 필요하기 때문에 메시지 브로커가 필요하다.

### 메시지 브로커의 핵심 역할
- 서비스간 커넥션이 실패하는 상황이 언제나 발생할 수 있기 때문에 
  메시지 브로커는 비동기로 메시지를 어딘가에 저장해두고,
  당장 메시지를 처리하지 못하더라도 나중에 처리할 수 있도록 하는 역할을 한다.

### 메시지 브로커의 형태
- 메시지 브로커는 크게 두 가지 형태로 나뉜다.
  - 메시지 큐
  - 이벤트 스트림

### 메시지 큐와 이벤트 스트림
- 메시지큐는 데이터를 생산하는 생산자와 데이터를 소비하는 소비자가 존재한다.
- 이벤트 스트림에서는 데이터를 생산하는 발행자와 데이터를 구독하는 구독자가 존재한다.
- 이 둘의 차이는 두가지가 있다.
  1. 방향성
     메시징 큐는 직접 소비자 큐에 메시지를 전달하는 방식이다. 2명의 소비자에게 보내려면 각각 보내야한다.
     이벤트 스트림은 발행자가 이벤트를 발행하면 이벤트 스트림에 저장되고, 소비자가 스트림에서 메시지를 풀해간다.  
  2. 데이터의 영속성
        메시지 큐는 메시지를 소비자에게 전달하면 메시지를 삭제한다.
        이벤트 스트림은 메시지를 소비자에게 전달해도 메시지를 삭제하지 않고 일정기간 보관한다.
    이 차이로 인해 메시징 큐는 1대1 통신에 적합하고, 이벤트 스트림은 1대다 통신에 유리하다.

### 레디스를 메시지 브로커로 사용하기
- 레디스의 PUB/SUB 기능을 이용하면 메시지 브로커를 구현할 수 있다.
  - fire and forget 패턴이 필요한 서비스에서 사용하기 좋다.
  - list 자료형이 메시지큐로 사용하기에 알맞다.
    list는 push와 pop을 지원하고, 블로킹 기능을 제공한다.
  - stream 자료형은 이벤트 스트림으로 사용하기에 알맞다.
    저장되는 데이터를 실시간으로 소비할 수도 있고, 저장돼 있는 데이터를 시간대별로 검색도 가능하다.

### 레디스의 PUB/SUB
- 레디스의 PUB/SUB은 최소한의 기능만을 제공한다.
- 메타데이터는 제공하지 않는다.
- publish 하기
  ```redis
    PUBLISH hello world
    (integer) 1
  ```
  구독자 수가 반환된다.
- subscribe 하기
``` redis
    SUBSCRIBE event1 event2
    1) "subscribe"
    2) "hello"
    3) (integer) 1
```
두개의 채널을 동시에 구독할 수 있다.
클라이언트가 구독자로 동작할 때에는 새로운 채널을 구독할 수 있지만
pub/sub과 관련되지 않은 다른 명령을 사용할 수 없다.

구독자가 수행할 수 있는 커맨드는 다음과 같다.
- SUBSCRIBE
  구독하기
- UNSUBSCRIBE
    구독 취소하기
- PUBLISH
    메시지 발행하기
- PSUBSCRIBE
    패턴으로 구독하기
- PUNSUBSCRIBE
    패턴으로 구독 취소하기
- QUIT
    구독 취소하고 연결 종료하기
- PING
    연결 확인하기
- RESET
    구독 취소하고 연결 재설정하기
- SSUBSRIBE
    구독하기
- SUNSUBSCRBE
    구독 취소하기

### 클러스터 구조의 PUB/SUB
- shared pub/sub
  레디스 7.0 이상부터는 shared pub/sub을 지원한다.
- SPUBLISH로 메시지를 발행하면 모든 노드에 전파되지 않고 복제본에만 전파한다.


### LIST를 메시지 큐로 사용하기
- list의 ex 기능 

 트위터의 타임라인 캐시를 예시로 유저 A가 트윗을 작성하면 
A를 팔로우하는 유저들의 타임라인에 트윗을 추가한다.
이때 RPUSHX를 사용하여 트윗을 추가하면 이미 캐시된 타임라인에만 데이터를 추가할 수 있다.
이 방식을 사용하면 자주 들어오지 않는 유저에 대해서는 캐시를 관리하지 않을 수 있다.
- list의 블로킹 기능

이벤트 기반 구조에서는 이벤트 루프를 돌며 신규 이벤트가 있는지 체크한다.
이 때 이벤트가 없으면 일정 시간 대기하는 폴링방식을 사용한다.
이는 불필요한 리소스를 사용하게 되므로 블로킹 기능을 사용하는 것이 좋다.
리스트의 BRPOP과 BLPOP은 블로킹 기능을 제공한다.
리스트에 데이터가 있으면 데이터를 반환하고, 없으면 블로킹하다가 nil을 반환한다.

- list를 이용한 원형 큐

RPOPLPUSH를 사용하면 원형큐를 사용할 수 있다.
어떤 서비스에서 사용할 수 있을까?

### STREAM

레디스의 스트림과 카프카
* 스트림이란?
  연속적인 데이터 흐름, 일정한 데이터 조각의 연속을 의미한다.
* 데이터의 저장
  카프카에서 스트림 데이터는 토픽이라는 개념에 저장된다. 토픽은 각각 분리된 스트림을 의미하며, 각 데이터를 관리하는 하나의 그룹을 의미한다.
  레디스에서는 하나의 스트림 자료구조가 하나의 스트림을 의미하낟. 하나의 키에 하나의 스트림을 사용한다.
  카프카는 시퀀스넘버로 메시지를 식별하고 레디스는 시간과 관련된 ID를 사용한다.
* 스트림 생성과 데이터 입력
  ```redis
  XADD EMAIL * subject "hello" body "world"
  ```
  존재하는 스트림이 없으면 새로 생성하고, 존재하면 데이터를 추가한다.
  * 을 사용하면 자동으로 생성되는 아이디를 사용하는 것이고
  ```redis
   XADD EMAIL 123-456 subject "hello" body "world"
  ```
    이렇게 사용하면 123-456이라는 아이디를 사용한다.

* 데이터의 조회
  * 실시간 리스닝
  ```redis
    XREAD BLOCK 0 STREAMS EMAIL 0
  ```
  위 커멘드의 동작은 메시지가 올때 까지 대기하고, EMAIL 스트림의 메시지 아이디가 0보다 큰값을 가져오게한다.
$ 를 사용하면 커맨드가 실행된 이후의 데이터만 가져올 수 있다.

* 특정한 데이터 조회
  ```redis
  XRANGE EMAIL 0 1000
  ```
  0부터 1000까지의 데이터를 조회한다.
  ```redis
  XRANGE EMAIL - +
  ```
모든 데이터를 조회한다.

### 소비자와 그룹
* 같은 데이터를 여러 사용자에게 제공하는 것을 팬아웃이라고 한다.
* 같은 역할의 여러개의 소비자를 이용해 팬아웃 구현이 가능하다.

* 스트림의 성능을 높이기 위해 병렬로 처리하게 구성할 수 있다.
  * 이때 메시지의 순서가 보장돼야하는 경우와 그렇지 않은 경우가 있다.
    * 레디스는 순서를 보장한다.
    * 카프카는 순서를 보장하지 않는다.
  * 카프카에서 순서를 보장하기 위해서는 소비자 그룹을 사용해야한다.
* 소비자 그룹
  * 카프카에서 소비자 그룹을 통해 여러 소비자를 그룹에 추가하고 토픽을 구독할 수 있다.
  * 레디스는 순서를 보장하기 때문에 카프카와는 다르다.
  ```redis
    XGROUP CREATE EMAIL EMAIL_GROUP $
  ```
    이렇게 그룹을 생성하고
    ```redis
        XREADGROUP GROUP EMAIL_GROUP consumer1 BLOCK 0 STREAMS EMAIL >
    ```
    이렇게 그룹을 읽을 수 있다.
\> 커멘드는 전달되지 않은 데이터를 가져오라는 의미이다
    COUNT 옵션을 사용하면 한번에 읽을 수 있는 데이터의 양을 제한할 수 있다.
    ```redis
    XREADGROUP GROUP EMAIL_GROUP consumer1 BLOCK 0 COUNT 10 STREAMS EMAIL >
    ```
XREADGROUP은 읽어오는 동작 자체가 소비자에 영향을 미치기 때문에 일종의 쓰기 커맨드라고 생각해야한다.

* 부하 분산의 관점에서 카프카와 레디스 비교
  * 레디스의 스트림은 파티션이라는 분할 없이도 여러 소비자에게 데이터를 분산시킬 수 있다.
  * 카프카는 토픽을 파티션으로 나누어 데이터를 분산시킨다.

  * 스트림과 소비자 그룹은 독립적으로 동작할 수 있다.
  * 하나의 소비자 그룹에서 여러개의 스트림을 구독할 수도 있다.
  
### ACK와 보류 리스트
* 여러 서비스가 메시지 브로커를 이용하고 있을때 장애가 발생한 경우, 어디까지 메시지가 전송되었고 전달된 데이터의 처리 유무를 인지하고 있어야한다.
* 레디스 Stream에서는 소비자 그룹에 속한 소비자가 메시지를 읽어가면 각 소비자 별로 읽어간 메시지에 대한 리스트를 생성하낟.
* 마지막으로 읽은 ID로 last_delivered_id를 업데이트한다.
* 레디스 스트림은 소비자별로 보류 리스트를 생성한다.
* ACK는 소비자가 메시지를 처리했음을 브로커에게 알리는 것이다.

* 현재 소비자 그룹에서 보류중인 리스트가 있는 지 확인하는 커멘드는
```redis
XPENDING EMAIL EMAIL_GROUP
1) (integer) 9
2) "12312312-0"
3) "12321388-0"
4) 1) 1) "consumer1"
      2) 1
    
   2) 1) "consumer2"
      2) 1
```
첫번째 값은 보류된 메시지 수
두번재는 보류된 메시지 아이디의 최소
세번째는 보류된 메시지 아이디의 최대값이다.
그 뒤로 소비자별로 보류된 리스트 수를 알려준다.

* XACK를 사용하여 데이터가 처리되었음을 알릴 수 있다.
```redis
XACK EMAIL EMAIL_GROUP 12312312-0
```

| 메시지의 보증 전략
1. at most once
   메시지가 한번만 전달되는 것을 보장한다.
2. at least once
   메시지가 적어도 한번은 전달되는 것을 보장한다.
3. exactly once
   메시지가 정확히 한번만 전달되는 것을 보장한다.

### 메시지의 재할당
* 장애난 서비스가 복구되지 않아 다른 소비자로 이동해야할 경우 메시지를 재할당할 수 있다.
```redis
XCLAIM EMAIL EMAIL_GROUP consumer1 0 12312312-0
```

### 메시지의 자동재할당
* 메시지의 자동재할당을 사용하면 메시지를 처리하지 않은 소비자가 있을 때 자동으로 메시지를 재할당할 수 있다.
```redis
XAUTOCLAIM EMAIL EMAIL_GROUP consumer1 360000 0-0 count 1
```

### 메시지의 수동재할당

